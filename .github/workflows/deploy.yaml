# .github/workflows/deploy.yml
name: Deploy S3 Website via Terraform Cloud

on:
  push:
    branches:
      - main # Trigger on pushes to the main branch
  pull_request:
    branches:
      - main # Trigger on pull requests to the main branch
  workflow_dispatch: # Allows manual trigger from GitHub UI

jobs:
  terraform_plan_and_apply:
    runs-on: ubuntu-latest
    environment: YOUR_TERRAFORM_CLOUD_WORKSPACE_ENVIRONMENT # Optional: If you use GitHub Environments for approvals
    
    env:
      AWS_EC2_METADATA_DISABLED: true # Disable EC2 metadata service for security reasons
      # Pass GitHub Secrets to Terraform variables using TF_VAR_ prefix
      PLAN_FILENAME: tfplan
      TF_VAR_aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      TF_VAR_aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set AWS_EC2_METADATA_DISABLED for all subsequent steps
        run: echo "AWS_EC2_METADATA_DISABLED=true" >> $GITHUB_ENV
        # This writes the environment variable to a special file that GitHub Actions
        # reads and applies to all *subsequent* steps in the same job.
        # This is generally more reliable for critical environment variables.

       # --- ADD THESE LINES HERE FOR AWS CREDENTIALS ---
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1 # Make sure this matches your S3 bucket region, or dynamically set it
      # --- END ADDITION ---
      
      
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.11.4 # Match your TFC version or use a compatible one
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }} # TFC API Token

      - name: Terraform Init
        id: init
        run: terraform init

      - name: Terraform Plan
        id: plan_output_step
        run: terraform plan -no-color -out=${{ env.PLAN_FILENAME }} # Save the plan
        

      - name: Check Terraform Plan Results
        id: plan_check # This ID is correct for your conditional logic
        # No 'env:' block for PLAN here, as we are getting it directly from `terraform show`

        run: |
          # Use 'terraform show' to get the human-readable output from the binary plan file
          PLAN_OUTPUT=$(terraform show -no-color ${{ env.PLAN_FILENAME }})

          echo "DEBUG: Raw plan output relevant lines for change detection:"
          echo "$PLAN_OUTPUT" | grep -E "No changes.|Plan: [0-9]+ to add, [0-9]+ to change, [0-9]+ to destroy." || true # print only relevant lines
          echo "--------------------------------------------------------"

          if echo "$PLAN_OUTPUT" | grep -q "No changes."; then
            echo "::notice file=main.tf::Terraform plan found no changes. Skipping apply."
            echo "has_changes=false" >> $GITHUB_OUTPUT # Correct syntax for setting output
            echo "DEBUG: has_changes set to false" 
          else 
            echo "::notice file=main.tf::Terraform plan found changes. Proceeding with apply."
            echo "has_changes=true" >> $GITHUB_OUTPUT # Correct syntax for setting output
            echo "DEBUG: has_changes set to true"
          fi 

        # Make sure `terraform show` output is not too large for `PLAN_OUTPUT` var if it's huge.
        # For most static sites, it will be fine.


      - name: Display Terraform Plan Summary (in Job Summary)
        # This step parses the saved plan file and outputs a markdown summary
        run: |
          PLAN_PATH=${{ env.PLAN_FILENAME }} # Path to the binary plan file
          # Use `terraform show` to get the human-readable output to parse
          TERRAFORM_PLAN_OUTPUT=$(terraform show -no-color "$PLAN_PATH")

          {
            # Check for no changes from the 'terraform show' output
            echo "$TERRAFORM_PLAN_OUTPUT" | grep -q "No changes. Your infrastructure matches the configuration." && {
              echo "## :white_check_mark: No changes detected."
              echo "Your infrastructure perfectly matches the Terraform configuration."
              exit 0
            }
            # Fallback for older "no changes" message
            echo "$TERRAFORM_PLAN_OUTPUT" | grep -q "No changes. No objects need to be destroyed." && {
              echo "## :white_check_mark: No changes detected."
              echo "Either you have not created any objects yet or the existing objects were already deleted outside of Terraform."
              exit 0
            }

            echo "## :bulb: Terraform Plan Details"
            echo "| Action | Resource |"
            echo "|--------|----------|"

            # Extract and format resource changes from 'terraform show' output
            echo "$TERRAFORM_PLAN_OUTPUT" | grep -E '^\S+ \S+\.\S+ (will be|must be|has been)' | \
            sed -e 's/^\([+-~]\)\s\+\(.*\)\s\+will be created/|:white_check_mark: create|\2|/' \
                -e 's/^\([+-~]\)\s\+\(.*\)\s\+will be destroyed/|:bangbang: destroy|\2|/' \
                -e 's/^\([+-~]\)\s\+\(.*\)\s\+will be replaced/|:recycle: replace|\2|/' \
                -e 's/^\([+-~]\)\s\+\(.*\)\s\+must be replaced/|:recycle: replace|\2|/' \
                -e 's/^\([+-~]\)\s\+\(.*\)\s\+will be updated in-place/|:arrows_counterclockwise: update|\2|/' \
                -e 's/^\([+-~]\)\s\+\(.*\)\s\+has been tainted/|:warning: tainted|\2|/'

            # Print the final plan summary line (e.g., "Plan: X to add, Y to change, Z to destroy.")
            echo "$TERRAFORM_PLAN_OUTPUT" | grep -E '^Plan:|^Changes to Outputs:' | sed -e 's/^/## /'

          } > plan_summary.md
          cat plan_summary.md >> $GITHUB_STEP_SUMMARY

      # Manual approval (optional, but good for CD)
      - name: Await Manual Approval
        if: github.event_name == 'pull_request' && steps.plan_check.outputs.has_changes == 'true'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }} # GitHub Token for API access
          approvers: pavan-bethanabotla-infosrc # Replace with GitHub username(s) or team(s)
          minimum-approvals: 1
          issue-title: "Approve Terraform Apply for ${{ github.ref }}"
          issue-body: "A Terraform plan is ready for review. Click 'Approve' to proceed with apply."
          exclude-workflow-initiator: false

      - name: Terraform Apply
        if: always() && (github.event_name != 'pull_request' || steps.plan_check.outputs.has_changes == 'true') # Only apply if there were changes or not a PR
        run: terraform apply -auto-approve ${{ env.PLAN_FILENAME }} # Apply the saved plan file